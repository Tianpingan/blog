操作系统是计算机方面的重要难点，在B站听Mooc多次听睡之后，决定以课本与为主，结合网上搜到的高频问题，对常见的操作系统知识做一个归纳整理。

下文中很多内容是转载，在文章的最后会一一注明。

------

[toc]



## **1 什么是进程与线程，有何区别？进程与程序有何区别？**

（1）线程是进程的一个**实体**，一个进程可以拥有**多个线程**，多个线程也可以**并发执行**。一个没有线程的进程也可以看做是单线程的，同样线程也经常被看做是一种轻量级的进程。并且进程可以不依赖于线程而单独存在，而线程则不然。

（2）进程是并发程序在一个数据集合上的一次**执行过程**，进程是系统进行**资源分配和调度**的独立单位，线程是进程的实体，它是比进程更小的能够独立执行的基本单元，线程自己不拥有任何**系统资源**，但是它可以访问其隶属进程的全部资源。

（3） 与进程的控制表**PCB**相似，线程也有自己的控制表**TCB**，但是TCB中所保存的线程状态比PCB表少得多。

进程的作用与定义：是为了提高CPU的执行效率，为了避免因等待而造成CPU空转以及其他计算机硬件资源的浪费而提出来的。

线程的引入：例如，有一个Web服务器要进程的方式并发地处理来自不同用户的网页访问请求的话，可以创建父进程和多个子进程的方式来进行处理，但是创建一个进程要花费较大的**系统开销**和占用较多的**资源**。除外，这些不同的用户子进程在执行的时候涉及到**进程上下文切换**，上下文切换是一个复杂的过程。所以，为了减少进程切换和创建的开销，提高执行效率和节省资源，人们在操作系统中引入了"线程（thread）"的概念。

  **进程**是具有**一定独立功能的程序关于某个数据集合上的一次运行活动**，进程是系统**进行资源分配和调度的一个独立单位**。

  线程是进程的一个实体，是**CPU调度和分派的基本单位**，它是比进程更小的能独立运行的基本单位。

  线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程**共享进程所拥有的全部资源。**一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以**并发执行。**由于线程基本不拥有系统资源，所以在进行切换时，线程切换的开销远远小于进程。

　进程与应用程序的区别在于应用程序作为一个**静态文件**存储在计算机系统的硬盘等存储空间中，而进程则是处于**动态条件**下由操作系统维护的**系统资源管理实体。**

 

|      | 定义                                                         | 使用系统运行资源情况                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 程序 | 计算机指令的集合，它以文件的形式存储在磁盘上。程序是**静态实体**（passive Entity），在多道程序系统中，它是不能独立运行的，更不能与其他程序并发执行。 | 不使用【程序不能申请系统资源，不能被系统调度，也不能作为独立运行的单位，因此，它不占用系统的运行资源】。 |
| 进程 | 通常被定义为一个正在运行的程序的实例，是一个程序在其自身的地址空间中的一次执行活动。定义：进程是**进程实体**（包括：程序段、相关的数据段、进程控制块PCB）的运行过程，是系统进行资源分配和调度的一个独立单位。 | 使用【进程是资源申请、调度和独立运行的单位，因此，它使用系统中的运行资源。】 |

 

  如果说操作系统引入进程的目的是为了提高程序并发执行，以提高资源利用率和系统吞吐量。那么操作系统中引入线程的目的，则是为了减少进程并发执行过程中所付出的时空开销，使操作系统能很好的并发执行。

　　进程process定义了一个**执行环境**，包括它自己私有的地址空间、一个句柄表，以及一个安全环境；线程则是一个**控制流**，有他自己的调用栈call stack，记录了它的执行历史。

　　线程由两个部分组成：1）**线程的内核对象**，操作系统用它来对线程实施管理。内核对象也是系统用来存放线程统计信息的地方。2）**线程堆栈**，它用于维护线程在执行代码时需要的所有参数和局部变量。当创建线程时，系统创建一个线程内核对象。该线程内核对象不是线程本身，而是操作系统用来管理线程的较小的数据结构。可以将线程内核对象视为由关于线程的统计信息组成的一个小型数据结构。

　　进程与线程的比较如下：

 

| 比较     | 进程                                                         | 线程                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 活泼性   | 不活泼（只是线程的容器）                                     | 活泼                                                         |
| 地址空间 | 系统赋予的独立的**虚拟地址空间**（对于32位进程来说，这个地址空间是4GB） | 在进程的地址空间执行代码。线程只有一个内核对象和一个堆栈，保留的记录很少，因此所需要的内存也很少。因为线程需要的**开销比进程少** |
| 调度     | 仅是**资源分配**的基本单位                                   | **独立调度、分派**的基本单位                                 |
| 并发性   | 仅进程间并发（传统OS）                                       | 进程间、线程间并发                                           |
| 拥有资源 | 资源拥有的基本单位                                           | 基本上不拥有资源                                             |
| 系统开销 | 创建、撤销、切换开销大                                       | 仅保存少量寄存器内容，开销小。                               |

## 2 **线程同步**的方式有哪些？

- **互斥量**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
- **信号量**：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
- **事件（信号）**：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

## 3 **windows**下的内存是如何管理的？

Windows提供了3种方法来进行内存管理：

**虚拟内存**，最适合用来管理**大型对象或者结构数组**；

**内存映射文件**，最适合用来管理**大型数据流**（通常来自文件）以及在单个计算机上运行**多个进程之间共享数据**；

**内存堆栈**，最适合用来管理**大量的小对象**。

## 4 **中断和轮询**的特点

对I/O设备的程序轮询的方式，是早期的计算机系统对I/O设备的一种管理方式。它定时对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的，则加以处理。在处理I/O设备的要求之后，处理机返回继续工作。尽管轮询需要时间，但轮询要比I/O设备的速度要快得多，所以一般不会发生不能及时处理的问题。当然，再快的处理机，能处理的输入输出设备的数量也是有一定限度的。而且，程序轮询毕竟占据了CPU相当一部分处理时间，因此，程序**轮询**是一种**效率较低**的方式，在现代计算机系统中已很少应用。

　　程序中断通常简称**中断**，是指CPU在正常运行程序的过程中，由于预先安排或发生了各种随机的内部或外部事件，使CPU中断正在运行的程序，而转到为响应的服务程序去处理。

　　轮询——效率低，等待时间很长，CPU利用率不高。

　　中断——容易遗漏一些问题，CPU利用率高。

## 5 什么是**临界区**？如何解决冲突？

每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区，进入后不允许其他进程进入。

　　（1）如果有若干进程要求进入空闲的临界区，**一次仅允许一个进程进入**；

　　（2）任何时候，**处于临界区内的进程不可多于一个**。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；

　　（3）进入临界区的进程要在**有限时间内退出**，以便其它进程能及时进入自己的临界区；

　　（4）如果进程不能进入自己的临界区，则应**让出CPU**，避免进程出现“忙等”现象。

## 6 说说**分段和分页**

段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个**二维地址空间**，相互独立，互不干扰。段式管理的优点是：**没有内碎片**（因为段大小可变，改变段大小来消除内碎片）。但**段换入换出时，会产生外碎片**（比如4k的段换5k的段，会产生1k的外碎片）

页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的**逻辑地址划分为固定大小的页（page）**，而**物理内存**划分为同样大小的**帧**，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：**没有外碎片**（因为页的大小固定），但**会产生内碎片**（一个页可能填充不满）。

两者的不同点：

目的不同：分页是由于系统管理的需要而不是用户的需要，它是**信息的物理单位**；分段的目的是为了能更好地满足用户的需要，它是**信息的逻辑单位**，它含有一组其**意义相对完整**的信息；

大小不同：页的**大小固定**且由系统决定，而段的长度却**不固定**，由其所完成的功能决定；

地址空间不同： 段向用户提供**二维地址空间**；页向用户提供的是**一维地址空间**；

信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；

内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。

- 段是信息的**逻辑单位**，它是根据**用户的需要**划分的，因此段对用户是可见的 ；页是信息的**物理单位**，是为了**管理主存**的方便而划分的，对用户是透明的。
- 段的大小**不固定**，有它所完成的功能决定；页大大小**固定**，由系统决定
- 段向用户提供**二维地址空间**；页向用户提供的是**一维地址空间**
- 段是信息的逻辑单位，便于**存储保护和信息的共享**，页的保护和共享**受到限制**。

​    页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。

　　段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要。

　　页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。

　　分页的作业地址空间是一维的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。

## 7 保持**进程同步**的方法？

进程间同步的主要方法有**原子操作、信号量机制、自旋锁、管程、会合、分布式系统**等。

## 8 **Linux**中常用到的命令

​    显示文件目录命令ls    如ls

　　改变当前目录命令cd    如cd /home

　　建立子目录mkdir      如mkdir xiong

　　删除子目录命令rmdir    如rmdir /mnt/cdrom

　　删除文件命令rm      如rm /ucdos.bat

　　文件复制命令cp      如cp /ucdos /fox

　　获取帮助信息命令man   如man ls

　　显示文件的内容less    如less mwm.lx

　　重定向与管道type     如type readme>>direct，将文件readme的内容追加到文direct中

## 9 **makefile文件**的作用是什么？

工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中。makefile**定义了一系列的规则**来指定哪些文件需要先编译，哪些文件需要后**编译**，哪些文件需要重新编译，甚至于进行更复杂的功能操作。

## 10 什么是**中断**？中断时CPU做什么工作？

中断是指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU**暂时中断**当前正在执行的程序而转去执行相应的事件处理程序。待**处理完毕后又返回**原来被中断处继续执行或调度新的进程执行的过程。

## 11 你知道操作系统的内容分为几块吗？什么叫做虚拟内存？他和主存的关系如何？内存管理属于操作系统的内容吗？

操作系统的主要组成部分：**进程和线程的管理，存储管理，设备管理，文件管理**。虚拟内存是一些系统页文件，存放在磁盘上，每个系统页文件大小为4K，物理内存也被分页，每个页大小也为4K，这样虚拟页文件和物理内存页就可以对应，实际上**虚拟内存就是用于物理内存的临时存放的磁盘空间**。页文件就是内存页，物理内存中每页叫物理页，磁盘上的页文件叫虚拟页，物理页+虚拟页就是系统所有使用的页文件的总和。

## 12 什么是**缓冲区溢出**？有什么危害？其原因是什么？

缓冲区溢出是指当计算机向缓冲区内填充数据时**超过了缓冲区本身的容量**，溢出的数据覆盖在合法数据上。造成缓冲区溢出的主原因是程序中**没有仔细检查用户输入的参数**。

危害有以下两点：

- **程序崩溃**，导致拒绝额服务
- 跳转并且**执行一段恶意代码**

## 13 什么是**死锁**？其条件是什么？怎样避免死锁？

死锁的概念：**在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。**通俗地讲，就是两个或多个进程被**无限期地阻塞、相互等待**的一种状态。

　　死锁产生的原因主要是： 系统资源不足； 进程推进顺序非法。

　　产生死锁的必要条件：

　　（1）**互斥**（mutualexclusion），一个资源每次只能被一个进程使用；

　　（2）**不可抢占**（nopreemption），进程已获得的资源，在未使用完之前，不能强行剥夺；

　　（3）**占有并等待（**hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放；

　　（4）**环形等待**（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。

　　这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

　　死锁的解除与预防：理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。

　　死锁的处理策略：**鸵鸟策略、预防策略、避免策略、检测与恢复策略**。

## 14 **进程间的通信**是如何实现的？

进程间通讯的方式：

- **管道**中还有命名管道和非命名管道之分，**非命名管道**只能用于**父子进程通讯**，**命名管道**可用于**非父子进程**，命名管道就是FIFO，管道是**先进先出**的通讯方式。FIFO是一种先进先出的队列。它类似于一个管道，只允许数据的单向流动。每个FIFO都有一个名字，允许不相关的进程访问同一个FIFO，因此也成为命名管道。
- **消息队列**：是用于两个进程之间的通讯，首先在一个进程中创建一个消息队列，然后再往消息队列中写数据，而另一个进程则从那个消息队列中取数据。需要注意的是，消息队列是用**创建文件的方式建立的**，如果一个进程向某个消息队列中写入了数据之后，另一个进程并没有取出数据，即使向消息队列中写数据的进程已经结束，保存在消息队列中的数据并没有消失，也就是说下次再从这个消息队列读数据的时候，就是上次的数据！！！
- **信号量**， 不能传递复杂消息，只能**用来同步**
- **共享内存**，只要首先创建一个共享内存区，其它进程按照一定的步骤就能访问到这个共享内存区中的数据，当然可读可写；

几种方式的比较：

- **管道**：**速度慢，容量有限**
- **消息队列**：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
- **信号量**：不能传递复杂消息，只能用来同步
- **共享内存区**：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了一块内存的。

进程通信，是指进程之间的信息交换（信息量少则一个状态或数值，多者则是成千上万个字节）。因此，对于用信号量进行的进程间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。

所谓高级进程通信指：用户可以利用操作系统所提供的一组通信命令传送大量数据的一种通信方式。操作系统隐藏了进程通信的实现细节。或者说，通信过程对用户是透明的。

高级通信机制可归结为三大类：

　　（1）**共享存储器系统**（存储器中划分的共享存储区）；实际操作中对应的是**“剪贴板”**（剪贴板实际上是系统维护管理的一块内存区域）的通信方式，比如举例如下：word进程按下ctrl+c，在ppt进程按下ctrl+v，即完成了word进程和ppt进程之间的通信，复制时将数据放入到剪贴板，粘贴时从剪贴板中取出数据，然后显示在ppt窗口上。

　　（2）**消息传递系统**（进程间的数据交换以消息（message）为单位，当今最流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。应用举例：**邮槽**（MailSlot）是基于广播通信体系设计出来的，它采用无连接的不可靠的数据传输。邮槽是一种单向通信机制，创建邮槽的服务器进程读取数据，打开邮槽的客户机进程写入数据。

　　（3）**管道通信系统**（管道即：连接读写进程以实现他们之间通信的共享文件（pipe文件，类似先进先出的队列，由一个进程写，另一进程读））。实际操作中，管道分为：匿名管道、命名管道。匿名管道是一个未命名的、单向管道，通过父进程和一个子进程之间传输数据。**匿名管道**只能实现**本地**机器上两个进程之间的通信，而不能实现跨网络的通信。**命名管道**不仅可以在本机上实现两个进程间的通信，还可以**跨网络**实现两个进程间的通信。

 

|                                                   | 同一机器两个进程间通信 | 跨网络通信 |
| ------------------------------------------------- | ---------------------- | ---------- |
| 剪贴板Clipboard                                   | 可以                   | 不可以     |
| 匿名管道Pipe                                      | 可以                   | 不可以     |
| 命名管道（点对点单一通信，数据量可较大）Namedpipe | 可以                   | 可以       |
| 邮槽（一对多，数据量较小，424字节以下）Mailslot   | 可以                   | 可以       |

## 15 **进程**有哪几种状态？

- 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源
- 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数
- 阻塞状态： 进程等待某种条件，在条件满足之前无法执行 

## 16 操作系统中**进程调度策略**有哪几种？

**FCFS**(先来先服务)，**优先级**，**时间片**轮转，**多级反馈**

**FCFS**(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU

**SJF(最短作业优先调度算法)**：平均等待时间最短，但难以知道下一个CPU区间长度

**优先级调度算法(**可以是抢占的，也可以是非抢占的)：**优先级越高越先分配到CPU**，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化

**时间片轮转调度算法**(可抢占的)：队列中**没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。**如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。

**多级队列调度算法**：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。

**多级反馈队列调度算法**：与多级队列调度算法相比，其**允许进程在队列之间移动**：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。

## 17 **ThreadLocal**与其它同步机制的比较

Threadlocal和其他所有的同步机制都是为了解决多线程中的对同一变量的访问冲突，在普通的同步机制中，是通过对对象加锁来实现多个线程对同一变量的安全访问的。这时该变量是多个线程共享的，使用这种同步机制需要很细致的分析在什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放该对象的索等等。所有这些都是因为多个线程共享了该资源造成的。Threadlocal就从另一个角度来解决多线程的并发访问，Threadlocal会**为每一个线程维护一个和该线程绑定的变量副本，从而隔离了多个线程的数据共享**，每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。

总结：当然ThreadLocal并不能替代同步机制，两者面向的问题领域不同。**同步机制是为了同步多个线程对相同资源的并发访问，是为了多个线程之间进行通信的有效方式；而ThreadLocal是隔离多个线程的数据共享，从根本上就不在多个线程之间共享资源**（变量），这样当然不需要对多个线程进行同步了。所以，如果你需要进行**多个线程之间进行通信，则使用同步机制；如果需要隔离多个线程之间的共享冲突，可以使用ThreadLocal**，这将极大地简化你的程序，使程序更加易读、简洁。

## 18 **局部性原理**

(1). **时间**上的局部性：**最近被访问的页**在不久的将来还会被访问；

(2). **空间上的局部性**：内存中被访问的页**周围的页**也很可能被访问。

## 19 **内存颠簸**

颠簸本质上是指**频繁的页调度**行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻**再次需要这个页**。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。

内存颠簸的解决策略包括：

如果是因为页面替换策略失误，可以**修改替换算法**来解决这个问题；

如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要**降低多道程序的数量**；

否则，还剩下两个办法：**终止该进程或增加物理内存容量**。

## 20 **虚拟内存**的应用与优点

虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页**被映射到物理内存**，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图所示。 注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。　　　　　　　　　　　　　　　　　　

　　由图可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。

![img](https://uploadfiles.nowcoder.com/images/20190723/220525776_1563877459292_F5CB0AD2C92C30DF24FC9C18034B313D)

虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：

- **在内存中可以保留多个进程，系统并发度提高**
- **解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大**

## 21 **页面置换**算法

**FIFO先进先出算法**：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；

LRU（Least recently use）**最近最少使用算法**：根据使用时间到现在的长短来判断；

LFU（Least frequently use**）最少使用次数算法**：根据使用次数来判断；

OPT（Optimal replacement）**最优置换算法**：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。

## 22 **线程**有几种状态，**进程**呢？

在 Java虚拟机 中，**线程**从最初的创建到最终的消亡，要经历若干个状态：**创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。**在给定的时间点上，一个线程只能处于一种状态，各状态的含义如下图所示：
**进程**：

- **就绪状态**：进程已获得除处理机以外的所需资源，等待分配处理机资源；
- **运行状态**：占用处理机资源运行，处于此状态的进程数小于等于CPU数；
- **阻塞状态**： 进程等待某种条件，在条件满足之前无法执行；

![img](https://uploadfiles.nowcoder.com/images/20190723/220525776_1563877459692_F5CB0AD2C92C30DF24FC9C18034B313D)

## 23 **孤儿进程，僵尸进程，守护进程**

　　**孤儿进程**：如果**父进程先退出,子进程还没退出**那么子进程将被托孤给init进程,这是子进程的父进程就是init进程(1号进程).其实还是很好理解的

​    **僵尸进程**：如果我们了解过linux进程状态及转换关系,我们应该知道进程这么多状态中有一种状态是僵死状态,就是进程终止后进入僵死状态(zombie),等待告知父进程自己终止,后才能完全消失.但是如果**一个进程已经终止了,但是其父进程还没有获取其状态,那么这个进程就称之为僵尸进程**.僵尸进程还会消耗一定的系统资源,并且还保留一些概要信息供父进程查询子进程的状态可以提供父进程想要的信息.一旦父进程得到想要的信息,僵尸进程就会结束.

  **守护进程**：同样我们需要了解一下什么是守护进程,**守护进程就是在后台运行,不与任何终端关联的进程**,通常情况下守护进程在系统启动时就在运行,它们以root用户或者其他特殊用户(apache和postfix)运行,并能处理一些系统级的任务.习惯上守护进程的名字通常以d结尾(sshd),但这些不是必须的.

## 24 **线程池**问题

多线程的异步执行方式，虽然能够最大限度发挥多核计算机的计算能力，但是如果不加控制，反而会对系统造成负担。线程本身也要占用内存空间，大量的线程会占用内存资源并且可能会导致Out of Memory。即便没有这样的情况，大量的线程回收也会给GC带来很大的压力。

为了避免重复的创建线程，**线程池的出现可以让线程进行复用**。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是**将这个线程归还给线程池**供其他任务使用。

------

操作系统常见面试题总结 https://blog.csdn.net/youngchang06hpu/article/details/8009947#commentBox

[操作系统面试题](https://www.cnblogs.com/memewry/archive/2012/08/25/2656966.html) https://www.cnblogs.com/memewry/archive/2012/08/25/2656966.html

常见面试题整理--操作系统篇（每位开发者必备）[ht](https://zhuanlan.zhihu.com/p/23755202)[tps://zhuanlan.zhihu.com/p/23755202](https://zhuanlan.zhihu.com/p/23755202)

面试/笔试第二弹 —— 操作系统面试问题集锦 https://blog.csdn.net/justloveyou_/article/details/78304294

孤儿进程，僵尸进程，守护进程：https://www.cnblogs.com/wannable/p/6021617.html

理解java线程池：https://www.cnblogs.com/superfj/p/7544971.html

 

------

附：常见知识点：https://blog.csdn.net/qq_39207948/article/details/80677811

1、**进程**是并发过程中程序的**执行过程**

2、进程的特征：结构特征 动态性 并发性 独立性 异步性

3、临界区指在每个进程中**访问临界资源的那段代码**

4，现在操作系统中**申请资源的基本单位是进程**，在CPU得到**执行的基本单位是线程**，进程是由**程序段、数据段、PCB**组成的

5，对**临界资源**应采取**互斥访问**方式来实现共享

6，**P.V操作**是一种**低级进程通信原语**

7，对于记录性信号量，在执行一次**P操作**时，信号量的值应当**减1**，当其值为小于0时进程应阻塞；在执行**V操作**时，信号量的值应当**加1**；当其值小于等于0时，应唤醒阻塞队列中的进程。

8，N个进程共享某一临界资源，（n-1）~1

9，**短作业优先算法**，T1<T2<T3平均周转时间为：T1+2XT2/3+T3/3

10，**响应比Rp**=（等待时间+要求服务时间）/要求服务器时间=响应时间/要求服务时间

11，**死锁**是指多个进程在运行过程中因争夺资源，而造成的一种僵局，当进程处于这种僵局状态时，若无外力作用，他们都将无法再向前推进。

死锁的避免是根据防止系统进入不安全状态。

产生死锁的根本原因是资源分配不当和资源数量不足，发生死锁的四个必要条件是：**互斥条件，请求和保持条件，不剥夺条件和环路等待条件**，**银行家算法**用于避免死锁

12，如果系统中有N个进程，最多为（N-1）个

13，若系统采用**轮转法调度进程**系统采用的是**剥夺式调度**

14，既考虑作业等待时间，又考虑作业执行时间的调度算法是**响应比优先调度算法**

15，**资源的有序分配策略**可以破坏死锁的“循环等待”

16，并非所有的不安全状态都必然会转为死锁状态，但当系统进入不安全状态后变有可能进入死锁状态，

17，**重定位**：在**作业地址空间**中使用的**逻辑地址变为内存物理地址**

18，支持程序放在不连续内存中储存管理方法有分取式分配，分段式分配，段页式分配页式存储主要特点是不要将作业同时全部装入到主存的的连续区域

19，适合多道程序运行的存储管理中，**存储保护**是为了防止各道作业的相互干扰

20，采用**页式存储管理**时，重定位的工作由**地址转换机**

21，段页式存储管理中的地址映像表是每个作业或进程一张段表，每个段一张页表

22，在虚拟页式存储管理方案中，完成将**页面调入内存**的工作的是**缺页中断处理**

23，分段管理和分页管理的主要区别是**分页管理有存储保护**，分段管理没有

24，在股低估分区分配中，可以不同但预先固定的

25，**不使用中断机构**的I/O控制方式是**程序I/O方式**

26，**spooling技术**能**独占设备改造成可以共享的虚拟设备** 

27，磁盘防伪中把数据从磁盘读出，叫做传输时间

28，**共享设备**指**同一时间内运行多个进程同时访问**的设备

29，通过软件的功能扩充，把原来独占的设备爱造成若干个可共享的设备，虚拟设备

30，**DMA方式**如果I/O设备不通过CPU来完成

31，设备独立性用户程序独立于具体物理设备的一种特性

32，虚拟设备一个物理设备变换成多个对应的逻辑设备

33，**通道**是一种**特殊的处理机**，通道按传递数据的方式分为：字节多路通道，数组选择通道，数组多路通道

通道涉及的数据结构是设备控制器，控制器控制块，通道控制块，系统设备表

34，**磁盘高速缓冲**设在内存中，目的是提高I/O磁盘速度

35，磁盘空间的地址有盘面号，柱面号，扇区号组成。访问磁盘的时间有 寻道时间，旋转等待时间，读写时间 

36，将系统段用参数翻译成设备操作命令的工作由设备无关的操作系统完成

37，向设备寄存器写入控制命令由**设备驱动程序**完成

38，寻找设备驱动程序由设备无关的操作系统软件完成

39，设备管理的功能是设备分配，缓冲区管理和实现物理I/O设备的操作

40，根据设备的固有属性特点，设备可分为**独占设备，共享设备和虚拟设备**

41，引入**缓冲区技术**可提高处理器执行程序和设备的输入输出操作的并行程序文件管理

42，物理文件的组织方式是由操作系统确定的，文件的顺序存取是按文件的逻辑号逐一存取

43，系统通过**树形目录结构**来解决重名问题

44，在**UNIX操作系统**中，把**输入输出设备看做特殊文件**

45，打开文件操作的主要工作是**把指定的目录复制到内存指定区域**

46，**文件路径名**是指从根目录到该文件所经历的路径中各符号名的集合

47，按逻辑结构划分，文件主要有两类：记录是文件，流式文件，**文件系统**的主要目的是实现对文件的**按名存取**

48，连续结构文件必须采用连续分配方式，而链接结构文件和索引结构文件都可采取**离散分配方式**

49，文件系统中，若文件的物理结构采用连续结构有关文件的物理位置的信息包括**首块地址和文件长度**

50，位示图可用于磁盘空间管理，在文件系统中，为实现文件保护，一般采用**口令，密码和访问控制**                 